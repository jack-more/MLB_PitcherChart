<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PITCH.FX // CLUSTER</title>
    <style>
        :root {
            /* ── Chassis (hardware body) ── */
            --chassis-bg: #c8cccf;
            --chassis-texture: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjYzhjY2NmIi8+CjxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiNjMGM0YzciIG9wYWNpdHk9IjAuMyIvPgo8L3N2Zz4=');

            /* ── Keys ── */
            --key-dark: #1e2124;
            --key-dark-shadow: #111315;
            --key-light: #e8eaed;
            --key-light-shadow: #b0b4b8;

            /* ── Accent ── */
            --accent-orange: #ff4400;
            --accent-orange-shadow: #cc3600;

            /* ── Screen ── */
            --screen-bg: #0a0a0a;

            /* ── Text ── */
            --text-on-light: #2a2d30;
            --text-on-dark: #f0f0f0;
            --text-label: #6e7175;
            --text-dim: #999;
            --text-muted: #666;

            /* ── Performance colors ── */
            --perf-green: #2a9d8f;
            --perf-yellow: #f4a261;
            --perf-red: #e63946;
            --perf-orange: #e76f51;
            --perf-teal: #a8dadc;

            /* ── Layout ── */
            --sidebar-w: 340px;
            --stat-panel-w: 320px;
            --header-h: 56px;
            --dock-h: 110px;

            /* ── Fonts ── */
            --font-tech: 'Courier New', Courier, monospace;
            --font-ui: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-font-smoothing: antialiased; }

        body {
            width: 100vw; height: 100vh; overflow: hidden;
            background-color: var(--chassis-bg);
            background-image: var(--chassis-texture);
            font-family: var(--font-ui);
            color: var(--text-on-light);
            display: grid;
            grid-template-columns: var(--sidebar-w) 1fr;
            grid-template-rows: var(--header-h) 1fr var(--dock-h);
            grid-template-areas:
                "header header"
                "sidebar screen"
                "dock dock";
        }

        /* ═══ LABEL SYSTEM ═══ */
        .label {
            font-family: var(--font-ui);
            font-size: 9px; font-weight: 700;
            text-transform: uppercase; letter-spacing: 0.5px;
            color: var(--text-label); display: block; margin-bottom: 4px;
        }
        .label-line {
            display: flex; align-items: center; gap: 6px; margin-bottom: 6px;
        }
        .label-line::before {
            content: ''; height: 1px; width: 12px; background: var(--text-label);
        }

        /* ═══ KEY SYSTEM (physical buttons) ═══ */
        .key {
            border-radius: 4px;
            display: inline-flex; align-items: center; justify-content: center;
            font-weight: 600; font-size: 11px; cursor: pointer;
            transition: transform 0.05s, box-shadow 0.05s;
            font-family: var(--font-ui);
        }
        .key-dark {
            background: var(--key-dark); color: var(--text-on-dark);
            box-shadow: 0 3px 0 var(--key-dark-shadow), 0 4px 4px rgba(0,0,0,0.2);
        }
        .key-dark:active { transform: translateY(2px); box-shadow: 0 1px 0 var(--key-dark-shadow); }
        .key-light {
            background: var(--key-light); color: var(--text-on-light);
            box-shadow: 0 3px 0 var(--key-light-shadow), 0 4px 4px rgba(0,0,0,0.1);
        }
        .key-light:active { transform: translateY(2px); box-shadow: 0 1px 0 var(--key-light-shadow); }
        .key-orange {
            background: var(--accent-orange); color: #fff;
            box-shadow: 0 3px 0 var(--accent-orange-shadow), 0 4px 4px rgba(0,0,0,0.2);
        }
        .key-orange:active { transform: translateY(2px); box-shadow: 0 1px 0 var(--accent-orange-shadow); }

        /* ═══ LED ═══ */
        .led {
            width: 8px; height: 8px; border-radius: 50%;
            background: #999; box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
        }
        .led.active {
            background: var(--accent-orange);
            box-shadow: 0 0 6px var(--accent-orange);
        }
        .led.green { background: #33cc33; box-shadow: 0 0 4px #33cc33; }

        /* ═══ HEADER ═══ */
        header {
            grid-area: header;
            display: flex; align-items: center; padding: 0 16px; gap: 12px;
            border-bottom: 1px solid rgba(0,0,0,0.08);
        }
        .brand {
            font-weight: 800; letter-spacing: -0.5px; color: var(--key-dark);
            font-size: 16px; display: flex; align-items: center; gap: 8px;
            white-space: nowrap;
        }
        .brand-icon {
            width: 18px; height: 18px; background: var(--accent-orange);
            border-radius: 2px;
        }

        .search-box {
            position: relative; flex: 0 0 280px;
        }
        .search-box input {
            width: 100%; background: #111; border: 1px solid #333;
            color: #fff; padding: 7px 10px; font-family: var(--font-tech);
            font-size: 11px; outline: none; border-radius: 3px;
        }
        .search-box input:focus { border-color: var(--accent-orange); }
        .search-box input::placeholder { color: #999; }

        .search-dropdown {
            position: absolute; top: 100%; left: 0; width: 100%; max-height: 260px;
            overflow-y: auto; background: #141414; border: 1px solid #333;
            border-top: none; z-index: 200; display: none; border-radius: 0 0 3px 3px;
        }
        .search-dropdown.visible { display: block; }
        .search-result {
            padding: 6px 10px; cursor: pointer; display: flex; justify-content: space-between;
            border-bottom: 1px solid #1a1a1a; font-size: 11px; color: #e0e0e0;
            font-family: var(--font-tech); font-weight: 600;
        }
        .search-result:hover, .search-result.highlighted { background: #1e1e1e; color: #fff; }
        .search-result .pa-label { color: #888; font-size: 10px; font-weight: 500; }

        .batter-stack {
            display: flex; gap: 4px; align-items: center; flex-wrap: wrap; flex: 1; overflow: hidden;
        }
        .batter-chip {
            background: var(--key-dark); border: 1px solid #333;
            color: #fff; padding: 4px 10px; font-size: 11px;
            font-family: var(--font-tech); border-radius: 3px;
            display: flex; align-items: center; gap: 4px; white-space: nowrap;
            font-weight: 700;
        }
        .batter-chip .remove {
            cursor: pointer; opacity: 0.4; font-size: 11px; margin-left: 2px;
        }
        .batter-chip .remove:hover { opacity: 1; color: var(--accent-orange); }

        .header-controls {
            display: flex; align-items: center; gap: 8px; margin-left: auto;
        }

        /* ═══ SIDEBAR ═══ */
        #sidebar {
            grid-area: sidebar;
            display: flex; flex-direction: column;
            border-right: 1px solid rgba(0,0,0,0.08);
            overflow: hidden;
        }

        .filter-bar {
            padding: 10px 14px; border-bottom: 1px solid rgba(0,0,0,0.08);
            display: flex; flex-direction: column; gap: 8px;
        }

        .key-row { display: flex; gap: 4px; flex-wrap: wrap; }
        .key-row .key {
            height: 26px; padding: 0 8px; font-size: 10px;
        }

        .archetype-list {
            flex: 1; overflow-y: auto; overflow-x: hidden;
        }

        /* Multi-batter column header */
        .arch-batter-cols {
            display: flex; align-items: center; padding: 4px 10px;
            border-bottom: 1px solid rgba(0,0,0,0.08);
            background: rgba(0,0,0,0.03); gap: 2px;
        }
        .arch-batter-cols .col-label {
            font-size: 9px; font-weight: 800; text-transform: uppercase;
            letter-spacing: 0.5px; color: var(--text-on-light); text-align: center;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .arch-batter-cols .col-archetype { flex: 1; text-align: left; }

        .arch-group-header {
            font-size: 10px; font-weight: 800; text-transform: uppercase;
            letter-spacing: 1px; padding: 10px 10px 4px; color: var(--text-on-light);
            border-top: 1px solid rgba(0,0,0,0.08);
        }
        .arch-item {
            display: flex; align-items: center; gap: 4px;
            padding: 6px 10px; cursor: pointer; font-size: 11px;
            transition: background 0.15s; border-left: 3px solid transparent;
        }
        .arch-item:hover { background: rgba(0,0,0,0.05); }
        .arch-item.selected {
            background: rgba(0,0,0,0.08);
            border-left-color: var(--accent-orange);
        }
        .arch-item.dimmed { opacity: 0.2; }
        .arch-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
        .arch-name { flex: 1; font-weight: 700; font-size: 11px; color: var(--key-dark); min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .arch-role {
            font-size: 8px; padding: 1px 4px; font-weight: 800; letter-spacing: 0.5px;
            border: 1px solid; border-radius: 2px; opacity: 0.85; flex-shrink: 0;
        }
        .arch-stat {
            font-size: 11px; font-weight: 800; font-family: var(--font-tech);
            width: 44px; text-align: center; flex-shrink: 0;
            padding: 2px 3px; border-radius: 3px;
        }
        .arch-stat.perf-great { background: rgba(42,157,143,0.15); color: var(--perf-green); }
        .arch-stat.perf-good { background: rgba(168,218,220,0.12); color: var(--perf-teal); }
        .arch-stat.perf-avg { color: var(--text-on-light); }
        .arch-stat.perf-poor { background: rgba(231,111,81,0.12); color: var(--perf-orange); }
        .arch-stat.perf-bad { background: rgba(230,57,70,0.15); color: var(--perf-red); }
        .arch-stat.empty { color: var(--text-muted); font-weight: 400; }
        .arch-count {
            font-size: 10px; color: var(--text-label); font-family: var(--font-tech);
            width: 24px; text-align: right; flex-shrink: 0; font-weight: 700;
        }

        .sidebar-status {
            padding: 8px 14px; border-top: 1px solid rgba(0,0,0,0.08);
            font-size: 10px; color: var(--text-on-light); font-family: var(--font-tech);
            font-weight: 700;
        }

        /* Range slider */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 6px;
            background: var(--key-dark); cursor: pointer; margin-top: -6px; border-radius: 2px;
        }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 2px; background: #aaa; }

        /* ═══ SCREEN (canvas area) ═══ */
        #screen {
            grid-area: screen;
            position: relative;
            background: var(--screen-bg);
            margin: 14px 14px 14px 0;
            border-radius: 6px;
            box-shadow: inset 0 0 0 2px #333, 0 8px 20px rgba(0,0,0,0.3);
            overflow: hidden;
            cursor: grab;
        }
        #screen:active { cursor: grabbing; }

        canvas { display: block; width: 100%; height: 100%; }

        .batter-badge {
            position: absolute; top: 14px; left: 50%; transform: translateX(-50%);
            background: var(--key-dark); border: 1px solid #333;
            color: #fff; padding: 7px 18px; border-radius: 20px;
            font-family: var(--font-tech); font-size: 13px; font-weight: 700; z-index: 10;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            opacity: 0; transition: opacity 0.3s; pointer-events: none;
            white-space: nowrap;
        }
        .batter-badge.visible { opacity: 1; }
        .batter-badge strong { color: #fff; margin-right: 6px; }

        #tooltip {
            position: absolute; background: rgba(20,20,20,0.95);
            border: 1px solid #333; color: #e8e8e8; padding: 7px 11px;
            border-radius: 4px; font-size: 11px; font-family: var(--font-tech);
            pointer-events: none; opacity: 0; transition: opacity 0.1s; z-index: 100;
            white-space: nowrap; font-weight: 600;
        }
        #tooltip.visible { opacity: 1; }

        /* ═══ STAT PANEL (slides in from right) ═══ */
        #stat-panel {
            position: absolute; top: 14px; right: 14px; width: 310px;
            max-height: calc(100% - 28px); overflow-y: auto;
            background: rgba(18,18,18,0.96); border: 1px solid #333;
            border-radius: 6px; padding: 16px;
            transform: translateX(330px); opacity: 0;
            transition: all 0.35s cubic-bezier(0.19,1,0.22,1);
            z-index: 20; box-shadow: -4px 0 20px rgba(0,0,0,0.5);
        }
        #stat-panel.visible { transform: translateX(0); opacity: 1; }
        .stat-close {
            position: absolute; top: 8px; right: 10px; background: none;
            border: none; color: #666; font-size: 16px; cursor: pointer;
        }
        .stat-close:hover { color: #fff; }
        .stat-header {
            font-weight: 700; font-size: 16px; color: #fff; margin-bottom: 2px;
        }
        .stat-sub {
            font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
            font-weight: 700; margin-bottom: 12px; padding-bottom: 6px;
            border-bottom: 1px solid #333; display: inline-block;
        }
        .stat-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-bottom: 12px;
        }
        .stat-cell {
            background: var(--key-dark); border-radius: 3px; padding: 6px; text-align: center;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
        }
        .stat-cell .s-label { font-size: 9px; color: #999; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 2px; font-weight: 600; }
        .stat-cell .s-val { font-size: 16px; font-weight: 800; color: #fff; font-family: var(--font-tech); }

        .section-hdr {
            font-size: 10px; color: #aaa; text-transform: uppercase;
            letter-spacing: 1px; margin: 12px 0 6px; border-bottom: 1px solid #333;
            padding-bottom: 3px; font-weight: 700;
        }
        .matchup-bar { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; font-size: 11px; font-family: var(--font-tech); color: #ddd; font-weight: 600; }
        .matchup-bar .yr { width: 30px; color: #999; font-weight: 700; }
        .matchup-bar .bar-track { flex: 1; height: 7px; background: #1a1a1a; overflow: hidden; border-radius: 2px; }
        .matchup-bar .bar-fill { height: 100%; transition: width 0.4s; border-radius: 2px; }
        .matchup-bar .woba-val { width: 38px; text-align: right; font-weight: 700; }
        .matchup-bar .pa-val { width: 36px; text-align: right; color: #888; font-size: 10px; font-weight: 600; }

        .profile-row { display: flex; justify-content: space-between; font-size: 12px; padding: 4px 0; color: #ccc; font-family: var(--font-tech); font-weight: 600; }
        .profile-row .pval { font-weight: 800; color: #fff; }

        .king-row { display: flex; justify-content: space-between; align-items: center; padding: 3px 0; font-size: 11px; border-bottom: 1px solid #1a1a1a; color: #e0e0e0; font-family: var(--font-tech); font-weight: 600; }
        .king-row .k-name { flex: 1; }
        .king-row .k-stat { width: 32px; text-align: right; font-weight: 800; }

        /* ═══ DOCK ═══ */
        #dock {
            grid-area: dock;
            display: flex; align-items: center; padding: 8px 20px; gap: 24px;
            border-top: 1px solid rgba(0,0,0,0.08);
        }

        .dock-module {
            flex: 1; min-width: 0;
        }
        .dock-title {
            font-size: 9px; font-weight: 800; text-transform: uppercase;
            letter-spacing: 1px; color: var(--text-label); margin-bottom: 4px;
        }
        .dock-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 3px 0; font-size: 11px; font-family: var(--font-tech);
            border-bottom: 1px solid rgba(0,0,0,0.05); font-weight: 600;
        }
        .dock-row .d-name { flex: 1; color: var(--key-dark); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 700; }
        .dock-row .d-stat { width: 40px; text-align: right; font-weight: 800; }
        .dock-row .d-stat.good { color: var(--perf-green); }
        .dock-row .d-stat.bad { color: var(--perf-red); }

        .saved-item {
            display: flex; justify-content: space-between;
            padding: 3px 0; font-size: 11px; font-family: var(--font-tech);
            cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.05);
            color: var(--key-dark); font-weight: 600;
        }
        .saved-item:hover { color: var(--accent-orange); }
        .saved-item .s-pa { color: var(--text-label); }

        .knob-group { display: flex; gap: 20px; }
        .knob-container { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .knob {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--key-dark);
            box-shadow: 0 3px 5px rgba(0,0,0,0.3), 0 2px 0 #000;
            position: relative;
        }
        .knob::after {
            content: ''; position: absolute; top: 5px; left: 50%;
            transform: translateX(-50%); width: 3px; height: 3px;
            border-radius: 50%; background: #555;
        }
        .knob.orange {
            background: var(--accent-orange);
            box-shadow: 0 3px 5px rgba(0,0,0,0.2), 0 2px 0 var(--accent-orange-shadow);
        }
        .knob.orange::after { background: #fff; }

        /* ═══ LOADER ═══ */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--chassis-bg); z-index: 500;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s;
        }
        .loader-brand {
            font-size: 20px; font-weight: 800; color: var(--key-dark);
            letter-spacing: -0.5px; display: flex; align-items: center; gap: 10px;
        }
        .loader-status {
            font-size: 10px; color: var(--text-label); font-family: var(--font-tech);
            margin-top: 12px; letter-spacing: 1px;
        }

        /* Scan overlay */
        #scan-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 50; pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }
        #scan-overlay.active { opacity: 1; }
        .scan-line {
            position: absolute; left: 0; width: 100%; height: 1px;
            background: linear-gradient(to right, transparent, var(--accent-orange), transparent);
            animation: scanDown 0.8s ease-in-out;
        }
        @keyframes scanDown { 0% { top: 0; opacity: 1; } 100% { top: 100%; opacity: 0; } }
        .scan-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            font-family: var(--font-tech); font-size: 11px; letter-spacing: 4px;
            color: var(--accent-orange); text-transform: uppercase;
            animation: scanTextAnim 0.8s ease-out;
        }
        @keyframes scanTextAnim { 0% { opacity:0; letter-spacing:16px; } 30% { opacity:1; letter-spacing:4px; } 80% { opacity:1; } 100% { opacity:0; } }

        /* ═══ PITCHER ROSTER ═══ */
        .roster-header {
            display: flex; align-items: center; justify-content: space-between;
            margin: 12px 0 6px; padding-bottom: 4px; border-bottom: 1px solid #222;
        }
        .roster-header .section-hdr { margin: 0; border: 0; padding: 0; }
        .roster-sort {
            display: flex; gap: 2px;
        }
        .roster-sort .sort-btn {
            background: #1a1a1a; border: 1px solid #2a2a2a; color: #666;
            font-size: 8px; padding: 2px 5px; cursor: pointer; font-family: var(--font-tech);
            text-transform: uppercase; border-radius: 2px; transition: all 0.15s;
        }
        .roster-sort .sort-btn.active { background: var(--accent-orange); color: #fff; border-color: var(--accent-orange); }
        .roster-sort .sort-btn:hover:not(.active) { border-color: #444; color: #aaa; }

        .roster-list { max-height: 280px; overflow-y: auto; margin-bottom: 8px; }
        .roster-row {
            display: grid; grid-template-columns: 1fr 32px 38px 28px 28px 38px;
            align-items: center; padding: 4px 4px; font-size: 11px;
            font-family: var(--font-tech); color: #ccc;
            border-bottom: 1px solid #1a1a1a; transition: background 0.1s;
            gap: 2px; font-weight: 600;
        }
        .roster-row:hover { background: rgba(255,255,255,0.04); }
        .roster-row .r-name {
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
            color: #eee; font-weight: 700;
        }
        .roster-row .r-val { text-align: right; font-size: 10px; }
        .roster-row .r-val.highlight { font-weight: 800; }
        .roster-head {
            display: grid; grid-template-columns: 1fr 32px 38px 28px 28px 38px;
            padding: 3px 4px; font-size: 9px; color: #888; text-transform: uppercase;
            letter-spacing: 0.5px; border-bottom: 1px solid #333; gap: 2px; font-weight: 700;
        }
        .roster-head span { text-align: right; }
        .roster-head span:first-child { text-align: left; }
        .roster-empty { font-size: 10px; color: #444; font-family: var(--font-tech); padding: 8px 0; text-align: center; }

        /* ═══ SEARCH HISTORY PANEL ═══ */
        .history-panel {
            position: absolute; top: var(--header-h); right: 0; width: 260px;
            max-height: 400px; overflow-y: auto;
            background: rgba(18,18,18,0.97); border: 1px solid #333;
            border-radius: 0 0 0 6px; z-index: 150;
            box-shadow: -4px 4px 16px rgba(0,0,0,0.4);
            transform: translateX(100%); opacity: 0;
            transition: all 0.25s cubic-bezier(0.19,1,0.22,1);
            padding: 10px;
        }
        .history-panel.visible { transform: translateX(0); opacity: 1; }
        .history-title {
            font-size: 9px; font-weight: 700; text-transform: uppercase;
            letter-spacing: 1px; color: var(--accent-orange); margin-bottom: 8px;
            display: flex; align-items: center; justify-content: space-between;
        }
        .history-title .h-clear { font-size: 8px; color: #555; cursor: pointer; font-weight: 400; }
        .history-title .h-clear:hover { color: var(--accent-orange); }
        .history-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 7px 8px; cursor: pointer; font-size: 12px;
            font-family: var(--font-tech); color: #e0e0e0; font-weight: 600;
            border-radius: 3px; margin-bottom: 2px; transition: all 0.15s;
            border: 1px solid transparent;
        }
        .history-item:hover { background: #1e1e1e; border-color: #333; }
        .history-item.active { background: rgba(255,68,0,0.08); border-color: var(--accent-orange); color: #fff; }
        .history-item .h-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-weight: 700; }
        .history-item .h-pa { font-size: 10px; color: #888; margin-left: 8px; white-space: nowrap; }
        .history-item .h-remove { opacity: 0; font-size: 11px; color: #888; margin-left: 6px; cursor: pointer; }
        .history-item:hover .h-remove { opacity: 0.6; }
        .history-item .h-remove:hover { color: var(--accent-orange); opacity: 1; }
        .history-empty { font-size: 11px; color: #666; font-family: var(--font-tech); text-align: center; padding: 16px 0; font-weight: 600; }

        ::-webkit-scrollbar { width: 3px; height: 3px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #aaa; border-radius: 2px; }
    </style>
</head>
<body>

    <div id="loader">
        <div class="loader-brand">
            <div style="width:24px;height:24px;background:var(--accent-orange);border-radius:3px;"></div>
            PITCH.FX // CLUSTER
        </div>
        <div class="loader-status" id="loader-status">INITIALIZING...</div>
    </div>

    <div id="scan-overlay"></div>

    <header>
        <div class="brand">
            <div class="brand-icon"></div>
            PITCH.FX // CLUSTER
        </div>

        <div class="search-box">
            <input type="text" id="batter-search" placeholder="SEARCH BATTER..." autocomplete="off">
            <div class="search-dropdown" id="search-dropdown"></div>
        </div>

        <div class="batter-stack" id="batter-stack"></div>

        <div class="header-controls">
            <div class="key key-dark" id="history-toggle" style="height:28px;padding:0 10px;font-size:9px;letter-spacing:0.5px;">HISTORY</div>
            <div class="led active" id="led-data"></div>
            <div class="led" id="led-batter"></div>
            <div class="led" id="led-scan"></div>
        </div>
    </header>

    <div class="history-panel" id="history-panel">
        <div class="history-title">
            <span>Search History</span>
            <span class="h-clear" id="history-clear">CLEAR ALL</span>
        </div>
        <div id="history-content"></div>
    </div>

    <aside id="sidebar">
        <div class="filter-bar">
            <div>
                <div class="label-line"><span class="label">Metric</span></div>
                <div class="key-row" id="metric-keys">
                    <div class="key key-orange" data-stat="wOBA">wOBA</div>
                    <div class="key key-dark" data-stat="BA">BA</div>
                    <div class="key key-dark" data-stat="SLG">SLG</div>
                    <div class="key key-dark" data-stat="K_pct">K%</div>
                    <div class="key key-dark" data-stat="BB_pct">BB%</div>
                </div>
            </div>
            <div>
                <div class="label-line"><span class="label">Filter</span></div>
                <div class="key-row" id="filter-keys">
                    <div class="key key-orange" data-filter="all">ALL</div>
                    <div class="key key-dark" data-filter="RHP">RHP</div>
                    <div class="key key-dark" data-filter="LHP">LHP</div>
                </div>
            </div>
            <div>
                <div style="display:flex;align-items:center;gap:8px;">
                    <span class="label" style="margin:0;">MIN PA: <span id="pa-val">10</span></span>
                    <input type="range" min="1" max="200" value="10" id="pa-slider" style="flex:1;">
                </div>
            </div>
            <div>
                <select id="year-select" style="width:100%;background:#f0f0f0;border:1px solid #bbb;color:#333;padding:4px 6px;font-family:var(--font-tech);font-size:9px;outline:none;border-radius:3px;">
                    <option value="all">ALL YEARS</option>
                </select>
            </div>
        </div>

        <div class="archetype-list" id="archetype-list"></div>

        <div class="sidebar-status" id="sidebar-status">LOADING...</div>
    </aside>

    <main id="screen">
        <canvas id="plot"></canvas>
        <div class="batter-badge" id="batter-badge">
            <strong id="badge-name"></strong> <span id="badge-stat"></span>
        </div>
        <div id="tooltip"></div>
        <div id="stat-panel">
            <button class="stat-close" id="stat-close">&times;</button>
            <div id="panel-content"></div>
        </div>
    </main>

    <footer id="dock">
        <div class="dock-module" id="dock-best">
            <div class="dock-title">Best Matchups</div>
            <div id="dock-best-content" style="font-size:9px;color:var(--text-label);">Search a batter</div>
        </div>
        <div class="dock-module" id="dock-worst">
            <div class="dock-title">Worst Matchups</div>
            <div id="dock-worst-content" style="font-size:9px;color:var(--text-label);">&mdash;</div>
        </div>
        <div class="dock-module" id="dock-kings">
            <div class="dock-title">Archetype Kings</div>
            <div id="dock-kings-content" style="font-size:9px;color:var(--text-label);">&mdash;</div>
        </div>
        <div class="dock-module" id="dock-saved">
            <div class="dock-title">Saved Searches</div>
            <div id="dock-saved-content" style="font-size:9px;color:var(--text-label);">No saved searches</div>
        </div>

        <div class="knob-group">
            <div class="knob-container">
                <div class="knob orange"></div>
                <span class="label">ZOOM</span>
            </div>
            <div class="knob-container">
                <div class="knob"></div>
                <span class="label">PAN</span>
            </div>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>
    <script>
    (function() {
        'use strict';

        // ═══════════════════════════════════════
        // DATA & STATE
        // ═══════════════════════════════════════
        const DATA = { clusters: {}, batters: [], pitcherSeasons: [], hitterVsCluster: [], hitterVsPitcher: [], archetypeKings: {} };

        const STATE = {
            activeBatters: [],
            selectedStat: 'wOBA',
            selectedYear: 'all',
            minPA: 10,
            visibleClusters: new Set(),
            highlightedCluster: null,
            savedSearches: JSON.parse(localStorage.getItem('pfx_saved') || '[]'),
        };

        // ═══════════════════════════════════════
        // DATA LOADING
        // ═══════════════════════════════════════
        async function loadJSON(url, label, setStatus) {
            setStatus('Loading ' + label + '...');
            const resp = await fetch(url);
            if (!resp.ok) throw new Error('Failed: ' + label);
            const text = await resp.text();
            setStatus('Parsing ' + label + ' (' + (text.length / 1e6).toFixed(1) + 'MB)...');
            return JSON.parse(text);
        }

        async function loadAllData() {
            const setStatus = (msg) => {
                const el = document.getElementById('loader-status');
                if (el) el.textContent = msg;
            };
            DATA.clusters = await loadJSON('clusters.json', 'cluster profiles', setStatus);
            DATA.batters = await loadJSON('batters.json', 'batter index', setStatus);
            DATA.pitcherSeasons = await loadJSON('pitcher_seasons.json', 'pitcher seasons', setStatus);
            DATA.hitterVsCluster = await loadJSON('hitter_vs_cluster.json', 'hitter matchups', setStatus);
            try { DATA.hitterVsPitcher = await loadJSON('hitter_vs_pitcher.json', 'pitcher matchups', setStatus); }
            catch(e) { DATA.hitterVsPitcher = []; }
            try { DATA.archetypeKings = await loadJSON('archetype_kings.json', 'archetype kings', setStatus); }
            catch(e) { DATA.archetypeKings = {}; }

            // Fix centroids with missing velo (avg_velo_FF = 0): compute from pitcher_seasons
            Object.entries(DATA.clusters).forEach(([cid, cluster]) => {
                const cent = cluster.centroid || {};
                if (!cent.avg_velo_FF || cent.avg_velo_FF === 0) {
                    const members = DATA.pitcherSeasons.filter(p => p.cluster === cid && p.avg_velo_FF > 0);
                    if (members.length > 0) {
                        cent.avg_velo_FF = members.reduce((s, p) => s + p.avg_velo_FF, 0) / members.length;
                    }
                }
                if (cent.pfx_x_avg == null) {
                    const members = DATA.pitcherSeasons.filter(p => p.cluster === cid && p.pfx_x_avg != null);
                    if (members.length > 0) {
                        cent.pfx_x_avg = members.reduce((s, p) => s + p.pfx_x_avg, 0) / members.length;
                    }
                }
            });

            // Build batter→pitcher matchup index for fast lookups
            DATA._hvpIndex = {};
            DATA.hitterVsPitcher.forEach(r => {
                if (!DATA._hvpIndex[r.b]) DATA._hvpIndex[r.b] = {};
                if (!DATA._hvpIndex[r.b][r.c]) DATA._hvpIndex[r.b][r.c] = [];
                DATA._hvpIndex[r.b][r.c].push(r);
            });

            STATE.visibleClusters = new Set(Object.keys(DATA.clusters));

            const years = [...new Set(DATA.hitterVsCluster.map(r => r.game_year))].sort();
            const sel = document.getElementById('year-select');
            years.forEach(y => { const o = document.createElement('option'); o.value = y; o.textContent = y; sel.appendChild(o); });
        }

        // ═══════════════════════════════════════
        // CANVAS SETUP
        // ═══════════════════════════════════════
        const canvas = document.getElementById('plot');
        const ctx = canvas.getContext('2d');
        const screenEl = document.getElementById('screen');

        // Data is in FEET — convert to inches for display (×12)
        // pfx_x_avg range: ~-1.5 to +1.5 feet → -18" to +18"
        // We'll use inches for the axis but read feet from data
        const MOVE_MIN = -18, MOVE_MAX = 18;    // inches
        const VELO_MIN = 82, VELO_MAX = 103;     // mph

        const MARGIN = { top: 40, right: 24, bottom: 40, left: 48 };

        let viewOffset = { x: 0, y: 0 };
        let viewZoom = 1.0;
        let isDragging = false, dragStart = { x: 0, y: 0 }, dragOffset = { x: 0, y: 0 };

        function cssW() { return canvas.getBoundingClientRect().width; }
        function cssH() { return canvas.getBoundingClientRect().height; }

        function plotArea() {
            return {
                x: MARGIN.left, y: MARGIN.top,
                w: cssW() - MARGIN.left - MARGIN.right,
                h: cssH() - MARGIN.top - MARGIN.bottom,
            };
        }

        // Data → CSS-pixel coords on canvas
        function d2c(moveInches, velo) {
            const p = plotArea();
            const nx = (moveInches - MOVE_MIN) / (MOVE_MAX - MOVE_MIN);
            const ny = 1 - (velo - VELO_MIN) / (VELO_MAX - VELO_MIN);
            const cx = p.x + nx * p.w;
            const cy = p.y + ny * p.h;
            const cw = cssW(), ch = cssH();
            return {
                x: (cx - cw / 2) * viewZoom + cw / 2 + viewOffset.x,
                y: (cy - ch / 2) * viewZoom + ch / 2 + viewOffset.y,
            };
        }

        function c2d(sx, sy) {
            const cw = cssW(), ch = cssH();
            const ux = (sx - viewOffset.x - cw / 2) / viewZoom + cw / 2;
            const uy = (sy - viewOffset.y - ch / 2) / viewZoom + ch / 2;
            const p = plotArea();
            const nx = (ux - p.x) / p.w;
            const ny = (uy - p.y) / p.h;
            return { moveInches: MOVE_MIN + nx * (MOVE_MAX - MOVE_MIN), velo: VELO_MAX - ny * (VELO_MAX - VELO_MIN) };
        }

        function resizeCanvas() {
            const dpr = Math.min(window.devicePixelRatio, 2);
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            render();
        }

        // ═══════════════════════════════════════
        // RENDERING
        // ═══════════════════════════════════════
        function render() {
            const w = cssW(), h = cssH();
            ctx.clearRect(0, 0, w, h);
            drawGrid(w, h);
            drawDots();
            drawCentroids();
            drawBatterLines();
        }

        function drawGrid(w, h) {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, w, h);

            ctx.strokeStyle = '#1e1e1e';
            ctx.lineWidth = 0.7;

            // Vertical grid every 3 inches
            for (let m = -18; m <= 18; m += 3) {
                const a = d2c(m, VELO_MIN), b = d2c(m, VELO_MAX);
                ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
            }
            // Horizontal grid every 2 mph
            for (let v = 84; v <= 102; v += 2) {
                const a = d2c(MOVE_MIN, v), b = d2c(MOVE_MAX, v);
                ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
            }

            // Center divider (x=0)
            const c0a = d2c(0, VELO_MIN), c0b = d2c(0, VELO_MAX);
            ctx.strokeStyle = '#2a2a2a'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.moveTo(c0a.x, c0a.y); ctx.lineTo(c0b.x, c0b.y); ctx.stroke();

            // Tick labels
            ctx.font = 'bold 11px "Courier New", monospace';
            ctx.fillStyle = '#aaa';
            ctx.textAlign = 'center';
            for (let m = -15; m <= 15; m += 6) {
                const p = d2c(m, VELO_MIN);
                ctx.fillText(m + '"', p.x, p.y + 14);
            }
            ctx.textAlign = 'right';
            for (let v = 84; v <= 102; v += 2) {
                const p = d2c(MOVE_MIN, v);
                ctx.fillText(v + '', p.x - 6, p.y + 3);
            }

            // Axis titles
            ctx.fillStyle = '#ccc';
            ctx.font = 'bold 13px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            const mb = d2c(0, VELO_MIN);
            ctx.fillText('HORIZONTAL BREAK (IN)', mb.x, mb.y + 32);

            ctx.save();
            const ml = d2c(MOVE_MIN, (VELO_MIN + VELO_MAX) / 2);
            ctx.translate(ml.x - 36, ml.y);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('FASTBALL VELOCITY (MPH)', 0, 0);
            ctx.restore();

            // Zone labels
            ctx.font = 'bold 13px -apple-system, sans-serif';
            ctx.fillStyle = '#bbb';
            ctx.textAlign = 'center';
            const lp = d2c(-9, VELO_MAX);
            const rp = d2c(9, VELO_MAX);
            ctx.fillText('\u2190 RHP', lp.x, lp.y - 6);
            ctx.fillText('LHP \u2192', rp.x, rp.y - 6);
        }

        function hexRgb(hex) {
            hex = hex.replace('#', '');
            return { r: parseInt(hex.substring(0,2),16), g: parseInt(hex.substring(2,4),16), b: parseInt(hex.substring(4,6),16) };
        }

        function drawDots() {
            const hl = STATE.highlightedCluster;
            const seasons = DATA.pitcherSeasons;
            for (let i = 0; i < seasons.length; i++) {
                const ps = seasons[i];
                const cluster = DATA.clusters[ps.cluster];
                if (!cluster) continue;
                if (!STATE.visibleClusters.has(ps.cluster)) continue;
                const moveIn = (ps.pfx_x_avg || 0) * 12; // feet → inches
                const velo = ps.avg_velo_FF;
                if (!velo || velo === 0) continue;

                const pos = d2c(moveIn, velo);
                const rgb = hexRgb(cluster.color);
                let alpha = 0.35, radius = 2;

                if (hl) {
                    if (ps.cluster === hl) { alpha = 0.85; radius = 3; }
                    else { alpha = 0.04; radius = 1.5; }
                }

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + alpha + ')';
                ctx.fill();
            }
        }

        function drawCentroids() {
            Object.entries(DATA.clusters).forEach(([id, cluster]) => {
                if (!STATE.visibleClusters.has(id)) return;
                const cent = cluster.centroid || {};
                const moveIn = (cent.pfx_x_avg || 0) * 12;
                const velo = cent.avg_velo_FF;
                if (!velo || velo === 0) return;

                const pos = d2c(moveIn, velo);
                const hl = STATE.highlightedCluster;
                const isHl = hl === id;
                const dim = hl && !isHl;
                const rgb = hexRgb(cluster.color);
                const alpha = dim ? 0.10 : 1;

                const outerR = isHl ? 24 : 18;
                const innerR = isHl ? 6 : 5;

                // Glow behind centroid
                if (!dim) {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, outerR + 6, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',0.06)';
                    ctx.fill();
                }

                // Outer ring
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, outerR, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + alpha + ')';
                ctx.lineWidth = isHl ? 3 : 2;
                ctx.stroke();

                // Inner dot
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, innerR, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + alpha + ')';
                ctx.fill();

                if (!dim) {
                    const role = cent.is_sp > 0.5 ? 'SP' : 'RP';

                    // Text background pill for readability
                    ctx.font = 'bold 12px -apple-system, sans-serif';
                    const nameW = ctx.measureText(cluster.short_name).width;
                    ctx.font = '9px "Courier New", monospace';
                    const roleW = ctx.measureText(cluster.hand + ' ' + role).width;
                    const pillW = Math.max(nameW, roleW) + 10;
                    ctx.fillStyle = 'rgba(10,10,10,0.75)';
                    ctx.beginPath();
                    const pillX = pos.x - pillW/2;
                    const pillY = pos.y + outerR + 3;
                    const pillH = 26;
                    const pillR = 4;
                    ctx.moveTo(pillX + pillR, pillY);
                    ctx.lineTo(pillX + pillW - pillR, pillY);
                    ctx.quadraticCurveTo(pillX + pillW, pillY, pillX + pillW, pillY + pillR);
                    ctx.lineTo(pillX + pillW, pillY + pillH - pillR);
                    ctx.quadraticCurveTo(pillX + pillW, pillY + pillH, pillX + pillW - pillR, pillY + pillH);
                    ctx.lineTo(pillX + pillR, pillY + pillH);
                    ctx.quadraticCurveTo(pillX, pillY + pillH, pillX, pillY + pillH - pillR);
                    ctx.lineTo(pillX, pillY + pillR);
                    ctx.quadraticCurveTo(pillX, pillY, pillX + pillR, pillY);
                    ctx.fill();

                    ctx.font = 'bold 12px -apple-system, sans-serif';
                    ctx.fillStyle = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + (alpha * 0.95) + ')';
                    ctx.textAlign = 'center';
                    ctx.fillText(cluster.short_name, pos.x, pos.y + outerR + 16);

                    ctx.font = '9px "Courier New", monospace';
                    ctx.fillStyle = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',0.55)';
                    ctx.fillText(cluster.hand + ' ' + role, pos.x, pos.y + outerR + 26);

                    // Stat chip when batter active
                    if (STATE.activeBatters.length > 0) {
                        const batter = STATE.activeBatters[STATE.activeBatters.length - 1];
                        const matchups = getMatchupData(batter);
                        const m = matchups.find(x => String(x.cluster) === id);
                        if (m && (m.PA || 0) >= STATE.minPA) {
                            const val = m[STATE.selectedStat] || 0;
                            const display = (STATE.selectedStat === 'K_pct' || STATE.selectedStat === 'BB_pct')
                                ? (val * 100).toFixed(0) + '%' : val.toFixed(3);
                            ctx.font = 'bold 12px "Courier New", monospace';
                            ctx.fillStyle = perfHex(STATE.selectedStat, val);
                            ctx.textAlign = 'center';
                            ctx.fillText(display, pos.x, pos.y - outerR - 6);
                        }
                    }
                }
            });
        }

        function wobaColor(w) {
            if (w >= 0.370) return '#2a9d8f';
            if (w >= 0.330) return '#a8dadc';
            if (w >= 0.290) return '#f4a261';
            if (w >= 0.250) return '#e76f51';
            return '#e63946';
        }

        function drawBatterLines() {
            if (STATE.activeBatters.length === 0) return;
            const batter = STATE.activeBatters[STATE.activeBatters.length - 1];
            const matchups = getMatchupData(batter);

            const badge = document.getElementById('batter-badge');
            const bRect = badge.getBoundingClientRect();
            const cRect = screenEl.getBoundingClientRect();
            const bx = bRect.left + bRect.width / 2 - cRect.left;
            const by = bRect.bottom - cRect.top + 2;

            Object.entries(DATA.clusters).forEach(([cid, cluster]) => {
                if (!STATE.visibleClusters.has(cid)) return;
                const cent = cluster.centroid || {};
                const moveIn = (cent.pfx_x_avg || 0) * 12;
                const velo = cent.avg_velo_FF;
                if (!velo || velo === 0) return;

                const hl = STATE.highlightedCluster;
                if (hl && cid !== hl) return;

                const pos = d2c(moveIn, velo);
                const m = matchups.find(x => String(x.cluster) === cid);
                const pa = m ? m.PA || 0 : 0;
                const statVal = m ? (m[STATE.selectedStat] || 0) : 0;

                if (pa < STATE.minPA) {
                    ctx.beginPath(); ctx.setLineDash([4,6]);
                    ctx.moveTo(bx, by); ctx.lineTo(pos.x, pos.y);
                    ctx.strokeStyle = 'rgba(60,60,60,0.3)'; ctx.lineWidth = 0.5;
                    ctx.stroke(); ctx.setLineDash([]);
                    return;
                }

                const color = perfHex(STATE.selectedStat, statVal);
                const thickness = Math.max(1.5, Math.min(5, pa / 80));

                // Glow
                ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = color; ctx.lineWidth = thickness + 5;
                ctx.globalAlpha = 0.12; ctx.stroke(); ctx.globalAlpha = 1;

                // Main line
                ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(pos.x, pos.y);
                ctx.strokeStyle = color; ctx.lineWidth = thickness;
                ctx.globalAlpha = 0.9; ctx.stroke(); ctx.globalAlpha = 1;
            });
        }

        // ═══════════════════════════════════════
        // CANVAS INTERACTION
        // ═══════════════════════════════════════
        const tooltipEl = document.getElementById('tooltip');

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            viewZoom = Math.max(0.5, Math.min(5, viewZoom * (e.deltaY > 0 ? 0.9 : 1.1)));
            render();
        }, { passive: false });

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
            dragOffset = { x: viewOffset.x, y: viewOffset.y };
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                viewOffset.x = dragOffset.x + (e.clientX - dragStart.x);
                viewOffset.y = dragOffset.y + (e.clientY - dragStart.y);
                render();
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;

            // Hover: centroids
            let found = null;
            Object.entries(DATA.clusters).forEach(([id, cl]) => {
                if (!STATE.visibleClusters.has(id)) return;
                const c = cl.centroid || {};
                if (!c.avg_velo_FF) return;
                const pos = d2c((c.pfx_x_avg||0)*12, c.avg_velo_FF);
                if (Math.sqrt((mx-pos.x)**2+(my-pos.y)**2) < 22) found = { id, cl, pos };
            });

            if (found) {
                const c = found.cl.centroid;
                const role = c.is_sp > 0.5 ? 'SP' : 'RP';
                tooltipEl.innerHTML = '<b style="color:'+found.cl.color+'">'+found.cl.short_name+'</b><br>'+found.cl.hand+' '+role+' \u00b7 '+found.cl.pitcher_count+' pitchers<br>Velo: '+(c.avg_velo_FF||0).toFixed(1)+' \u00b7 Whiff: '+((c.whiff_rate||0)*100).toFixed(0)+'%';
                tooltipEl.style.left = (e.clientX - screenEl.getBoundingClientRect().left + 12) + 'px';
                tooltipEl.style.top = (e.clientY - screenEl.getBoundingClientRect().top - 10) + 'px';
                tooltipEl.classList.add('visible');
                canvas.style.cursor = 'pointer';
                return;
            }

            // Hover: pitcher dots
            let closestDot = null, closestDist = 8;
            for (let i = 0; i < DATA.pitcherSeasons.length; i++) {
                const ps = DATA.pitcherSeasons[i];
                if (!STATE.visibleClusters.has(ps.cluster)) continue;
                if (!ps.avg_velo_FF) continue;
                const pos = d2c((ps.pfx_x_avg||0)*12, ps.avg_velo_FF);
                const dist = Math.sqrt((mx-pos.x)**2+(my-pos.y)**2);
                if (dist < closestDist) { closestDist = dist; closestDot = { ps, pos }; }
            }

            if (closestDot) {
                const ps = closestDot.ps;
                const cl = DATA.clusters[ps.cluster];
                tooltipEl.innerHTML = '<b>'+fmtName(ps.player_name)+'</b> ('+ps.game_year+')<br><span style="color:'+(cl?.color||'#888')+'">'+( cl?.short_name||'')+'</span> \u00b7 '+(ps.avg_velo_FF||0).toFixed(1)+' mph';
                tooltipEl.style.left = (e.clientX - screenEl.getBoundingClientRect().left + 12) + 'px';
                tooltipEl.style.top = (e.clientY - screenEl.getBoundingClientRect().top - 10) + 'px';
                tooltipEl.classList.add('visible');
                canvas.style.cursor = 'crosshair';
            } else {
                tooltipEl.classList.remove('visible');
                canvas.style.cursor = 'grab';
            }
        });

        canvas.addEventListener('mouseup', () => { isDragging = false; canvas.style.cursor = 'grab'; });
        canvas.addEventListener('mouseleave', () => { isDragging = false; tooltipEl.classList.remove('visible'); });

        canvas.addEventListener('click', (e) => {
            if (isDragging) return;
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left, my = e.clientY - rect.top;

            // Priority 1: cluster centroid clicks
            let centroidHit = false;
            Object.entries(DATA.clusters).forEach(([id, cl]) => {
                if (centroidHit) return;
                if (!STATE.visibleClusters.has(id)) return;
                const c = cl.centroid || {};
                if (!c.avg_velo_FF) return;
                const pos = d2c((c.pfx_x_avg||0)*12, c.avg_velo_FF);
                if (Math.sqrt((mx-pos.x)**2+(my-pos.y)**2) < 22) {
                    centroidHit = true;
                    const ab = STATE.activeBatters.length > 0 ? STATE.activeBatters[STATE.activeBatters.length-1] : null;
                    showStatPanel(ab, id);
                }
            });
            if (centroidHit) return;

            // Priority 2: individual pitcher dot clicks
            let closestDot = null, closestDist = 12;
            for (let i = 0; i < DATA.pitcherSeasons.length; i++) {
                const ps = DATA.pitcherSeasons[i];
                if (!STATE.visibleClusters.has(ps.cluster)) continue;
                if (!ps.avg_velo_FF) continue;
                const pos = d2c((ps.pfx_x_avg||0)*12, ps.avg_velo_FF);
                const dist = Math.sqrt((mx-pos.x)**2+(my-pos.y)**2);
                if (dist < closestDist) { closestDist = dist; closestDot = ps; }
            }
            if (closestDot) {
                const ab = STATE.activeBatters.length > 0 ? STATE.activeBatters[STATE.activeBatters.length-1] : null;
                showPitcherStatPanel(closestDot, ab);
            }
        });

        // ═══════════════════════════════════════
        // BATTER SYSTEM
        // ═══════════════════════════════════════
        function deriveStats(r) {
            const pa=r.PA||0, ab=r.AB||0, h=r.H||0, hr=r.HR||0, bb=r.BB||0, k=r.K||0, hbp=r.HBP||0;
            const s=r.singles||0, d=r.doubles||0, t=r.triples||0;
            r.BA = ab>0 ? h/ab : 0; r.OBP = pa>0 ? (h+bb+hbp)/pa : 0;
            r.SLG = ab>0 ? (s+2*d+3*t+4*hr)/ab : 0; r.K_pct = pa>0 ? k/pa : 0; r.BB_pct = pa>0 ? bb/pa : 0;
            return r;
        }

        function getMatchupData(batter) {
            let rows = DATA.hitterVsCluster.filter(r => r.batter === batter.batter);
            if (STATE.selectedYear !== 'all') rows = rows.filter(r => r.game_year === parseInt(STATE.selectedYear));
            if (STATE.selectedYear === 'all' && rows.length > 0) {
                const grouped = {};
                rows.forEach(r => {
                    const k = r.cluster;
                    if (!grouped[k]) grouped[k] = { cluster:k, PA:0, AB:0, H:0, HR:0, BB:0, K:0, HBP:0, singles:0, doubles:0, triples:0, woba_sum:0 };
                    const g = grouped[k];
                    g.PA+=r.PA||0; g.AB+=r.AB||0; g.H+=r.H||0; g.HR+=r.HR||0; g.BB+=r.BB||0; g.K+=r.K||0;
                    g.HBP+=r.HBP||0; g.singles+=r.singles||0; g.doubles+=r.doubles||0; g.triples+=r.triples||0;
                    g.woba_sum+=(r.wOBA||0)*(r.PA||0);
                });
                return Object.values(grouped).map(g => { g.wOBA = g.PA>0 ? g.woba_sum/g.PA : 0; return deriveStats(g); });
            }
            return rows.map(r => deriveStats({...r}));
        }

        function spawnBatter(batter) {
            const matchups = getMatchupData(batter);
            const totalPA = matchups.reduce((s,r)=>s+(r.PA||0),0);
            const totalWoba = matchups.reduce((s,r)=>s+(r.wOBA||0)*(r.PA||0),0);
            const ow = totalPA > 0 ? totalWoba/totalPA : 0;

            document.getElementById('badge-name').textContent = fmtName(batter.batter_name);
            document.getElementById('badge-stat').textContent = ow.toFixed(3) + ' wOBA \u00b7 ' + totalPA.toLocaleString() + ' PA';
            document.getElementById('batter-badge').classList.add('visible');
            document.getElementById('led-batter').classList.add('active');

            updateDock(batter, matchups);
            saveSearch(batter);
            buildArchetypeList();
            render();
        }

        function clearBatter() {
            document.getElementById('batter-badge').classList.remove('visible');
            document.getElementById('led-batter').classList.remove('active');
            document.getElementById('stat-panel').classList.remove('visible');
            render();
        }

        function refreshData() {
            if (STATE.activeBatters.length === 0) return;
            const b = STATE.activeBatters[STATE.activeBatters.length-1];
            updateDock(b, getMatchupData(b));
            render();
        }

        // ═══════════════════════════════════════
        // STAT PANEL
        // ═══════════════════════════════════════
        function showStatPanel(batterObj, clusterId) {
            const cluster = DATA.clusters[clusterId];
            if (!cluster) return;
            const panel = document.getElementById('stat-panel');
            const content = document.getElementById('panel-content');
            const cent = cluster.centroid || {};
            const role = cent.is_sp > 0.5 ? 'SP' : 'RP';

            let html = '';
            if (batterObj) {
                const yearRows = DATA.hitterVsCluster.filter(r => r.batter === batterObj.batter && String(r.cluster) === clusterId).sort((a,b)=>a.game_year-b.game_year);
                const tot = { PA:0,AB:0,H:0,HR:0,BB:0,K:0,HBP:0,singles:0,doubles:0,triples:0 };
                yearRows.forEach(r => { tot.PA+=r.PA||0; tot.AB+=r.AB||0; tot.H+=r.H||0; tot.HR+=r.HR||0; tot.BB+=r.BB||0; tot.K+=r.K||0; tot.HBP+=r.HBP||0; tot.singles+=r.singles||0; tot.doubles+=r.doubles||0; tot.triples+=r.triples||0; });
                const ba = tot.AB>0?(tot.H/tot.AB).toFixed(3):'.000';
                const obp = tot.PA>0?((tot.H+tot.BB+tot.HBP)/tot.PA).toFixed(3):'.000';
                const slg = tot.AB>0?((tot.singles+2*tot.doubles+3*tot.triples+4*tot.HR)/tot.AB).toFixed(3):'.000';
                const kp = tot.PA>0?((tot.K/tot.PA)*100).toFixed(1)+'%':'0%';
                const bbp = tot.PA>0?((tot.BB/tot.PA)*100).toFixed(1)+'%':'0%';

                html += '<div class="stat-header">'+fmtName(batterObj.batter_name)+'</div>';
                html += '<div class="stat-sub" style="color:'+cluster.color+'">vs '+cluster.short_name+' ('+cluster.hand+' '+role+')</div>';
                html += '<div class="stat-grid">';
                html += statCell('PA',tot.PA)+statCell('BA',ba)+statCell('OBP',obp);
                html += statCell('SLG',slg)+statCell('HR',tot.HR)+statCell('K%',kp);
                html += statCell('BB%',bbp)+statCell('H',tot.H)+statCell('2B',tot.doubles);
                html += '</div>';

                if (yearRows.length > 1) {
                    html += '<div class="section-hdr">Year-by-Year wOBA</div>';
                    yearRows.forEach(r => {
                        const w = r.wOBA||0;
                        const bw = Math.min(100,Math.max(5,(w/0.45)*100));
                        html += '<div class="matchup-bar"><span class="yr">'+r.game_year+'</span><div class="bar-track"><div class="bar-fill" style="width:'+bw+'%;background:'+wobaColor(w)+';"></div></div><span class="woba-val">'+w.toFixed(3)+'</span><span class="pa-val">'+r.PA+' PA</span></div>';
                    });
                }

                // ── Pitcher Roster vs This Batter ──
                const pitcherMatchups = (DATA._hvpIndex[batterObj.batter] || {})[clusterId] || [];
                if (pitcherMatchups.length > 0) {
                    html += '<div class="roster-header">';
                    html += '<span class="section-hdr">Pitchers in Group ('+pitcherMatchups.length+')</span>';
                    html += '<div class="roster-sort">';
                    html += '<span class="sort-btn active" data-sort="pa">PA</span>';
                    html += '<span class="sort-btn" data-sort="ba">BA</span>';
                    html += '<span class="sort-btn" data-sort="hr">HR</span>';
                    html += '<span class="sort-btn" data-sort="k">K</span>';
                    html += '</div></div>';
                    html += '<div class="roster-head"><span>PITCHER</span><span>PA</span><span>BA</span><span>HR</span><span>K</span><span>WHIFF</span></div>';
                    html += '<div class="roster-list" id="roster-list" data-cluster="'+clusterId+'" data-batter="'+batterObj.batter+'">';
                    const sorted = [...pitcherMatchups].sort((a,b) => (b.pa||0) - (a.pa||0));
                    sorted.forEach(m => {
                        const baVal = m.ba != null ? m.ba.toFixed(3) : '\u2014';
                        const whiff = m.w != null ? (m.w*100).toFixed(0)+'%' : '\u2014';
                        const baColor = m.ba != null ? (m.ba >= 0.300 ? 'color:var(--perf-green)' : m.ba <= 0.180 ? 'color:var(--perf-red)' : '') : '';
                        html += '<div class="roster-row">';
                        html += '<span class="r-name">'+fmtName(m.pn)+'</span>';
                        html += '<span class="r-val">'+(m.pa||0)+'</span>';
                        html += '<span class="r-val highlight" style="'+baColor+'">'+baVal+'</span>';
                        html += '<span class="r-val">'+(m.hr||0)+'</span>';
                        html += '<span class="r-val">'+(m.k||0)+'</span>';
                        html += '<span class="r-val">'+whiff+'</span>';
                        html += '</div>';
                    });
                    html += '</div>';
                } else {
                    html += '<div class="section-hdr">Pitchers in Group</div>';
                    html += '<div class="roster-empty">No individual matchup data</div>';
                }
            } else {
                html += '<div class="stat-header" style="color:'+cluster.color+'">'+cluster.short_name+'</div>';
                html += '<div class="stat-sub" style="color:'+cluster.color+'">'+cluster.hand+' '+role+' \u2014 '+cluster.pitcher_count+' pitchers</div>';
                html += '<div class="section-hdr">Cluster Profile</div>';
                if (cent.avg_velo_FF>0) html += '<div class="profile-row"><span>Avg Fastball</span><span class="pval">'+(cent.avg_velo_FF).toFixed(1)+' mph</span></div>';
                html += '<div class="profile-row"><span>Whiff Rate</span><span class="pval">'+((cent.whiff_rate||0)*100).toFixed(1)+'%</span></div>';
                html += '<div class="profile-row"><span>Zone Rate</span><span class="pval">'+((cent.zone_rate||0)*100).toFixed(1)+'%</span></div>';
                html += '<div class="profile-row"><span>GB Rate</span><span class="pval">'+((cent.groundball_rate||0)*100).toFixed(1)+'%</span></div>';
                html += '<div class="profile-row"><span>Arm Angle</span><span class="pval">'+(cent.arm_angle||0).toFixed(1)+'\u00b0</span></div>';
                if (cent.pfx_x_avg!=null) html += '<div class="profile-row"><span>H-Break</span><span class="pval">'+((cent.pfx_x_avg)*12).toFixed(1)+'"</span></div>';
                if (cent.pfx_z_avg!=null) html += '<div class="profile-row"><span>V-Break</span><span class="pval">'+((cent.pfx_z_avg)*12).toFixed(1)+'"</span></div>';
                const pitches = ['FF','SI','FC','SL','CH','CU','FS','KC','ST','SV','KN'].map(p=>({p,v:cent['pct_'+p]||0})).filter(x=>x.v>0.05).sort((a,b)=>b.v-a.v);
                html += '<div class="profile-row"><span>Top Pitches</span><span class="pval">'+pitches.map(x=>x.p+' '+((x.v)*100).toFixed(0)+'%').join(', ')+'</span></div>';

                // Pitcher roster (no batter context — show cluster members with their stats)
                const members = DATA.pitcherSeasons.filter(p => p.cluster === clusterId);
                // Dedupe by pitcher ID, keep latest season
                const seen = {};
                members.forEach(p => {
                    if (!seen[p.pitcher] || p.game_year > seen[p.pitcher].game_year) seen[p.pitcher] = p;
                });
                const uniquePitchers = Object.values(seen).sort((a,b) => (b.avg_velo_FF||0) - (a.avg_velo_FF||0));
                if (uniquePitchers.length > 0) {
                    html += '<div class="section-hdr">Pitchers ('+uniquePitchers.length+' unique)</div>';
                    html += '<div class="roster-head"><span>PITCHER</span><span>YR</span><span>VELO</span><span></span><span></span><span>WHIFF</span></div>';
                    html += '<div class="roster-list">';
                    uniquePitchers.slice(0,50).forEach(p => {
                        html += '<div class="roster-row">';
                        html += '<span class="r-name">'+fmtName(p.player_name)+'</span>';
                        html += '<span class="r-val">'+p.game_year+'</span>';
                        html += '<span class="r-val highlight">'+(p.avg_velo_FF||0).toFixed(1)+'</span>';
                        html += '<span class="r-val"></span>';
                        html += '<span class="r-val"></span>';
                        html += '<span class="r-val">'+((p.whiff_rate||0)*100).toFixed(0)+'%</span>';
                        html += '</div>';
                    });
                    if (uniquePitchers.length > 50) html += '<div class="roster-empty">+'+(uniquePitchers.length-50)+' more</div>';
                    html += '</div>';
                }
            }

            // Kings
            const kings = DATA.archetypeKings[clusterId] || [];
            if (kings.length > 0) {
                html += '<div class="section-hdr">Kings of '+cluster.short_name+'</div>';
                kings.slice(0,8).forEach(k => {
                    html += '<div class="king-row"><span class="k-name">'+k.name+'</span><span class="k-stat" style="width:24px;">'+k.seasons+'yr</span><span class="k-stat" style="color:var(--perf-green);">'+(k.avg_velo>0?k.avg_velo.toFixed(0):'\u2014')+'</span><span class="k-stat" style="color:var(--perf-red);">'+((k.avg_whiff||0)*100).toFixed(0)+'%</span></div>';
                });
            }

            // Examples
            html += '<div class="section-hdr">Examples</div><div style="font-size:9px;color:#666;font-family:var(--font-tech);">';
            (cluster.example_pitchers||[]).forEach(p => { html += '<div style="margin-bottom:1px;">'+p+'</div>'; });
            html += '</div>';

            content.innerHTML = html;
            panel.classList.add('visible');
            STATE.highlightedCluster = clusterId;
            render();
            buildArchetypeList();
        }

        function statCell(label, val) {
            return '<div class="stat-cell"><div class="s-label">'+label+'</div><div class="s-val">'+val+'</div></div>';
        }

        // ═══════════════════════════════════════
        // PITCHER DOT STAT PANEL
        // ═══════════════════════════════════════
        function showPitcherStatPanel(ps, batterObj) {
            const cluster = DATA.clusters[ps.cluster];
            if (!cluster) return;
            const panel = document.getElementById('stat-panel');
            const content = document.getElementById('panel-content');
            const cent = cluster.centroid || {};
            const role = ps.is_sp ? 'SP' : 'RP';

            let html = '';
            html += '<div class="stat-header">'+fmtName(ps.player_name)+'</div>';
            html += '<div class="stat-sub" style="color:'+cluster.color+'">'+ps.game_year+' // '+cluster.short_name+'</div>';

            // Pitcher profile stats
            html += '<div class="section-hdr">Pitcher Profile</div>';
            html += '<div class="stat-grid">';
            html += statCell('VELO', (ps.avg_velo_FF||0).toFixed(1));
            html += statCell('WHIFF', ((ps.whiff_rate||0)*100).toFixed(0)+'%');
            html += statCell('ARM', (ps.arm_angle||0).toFixed(0)+'\u00b0');
            html += '</div>';
            html += '<div class="profile-row"><span>Hand</span><span class="pval">'+(ps.is_rhp ? 'Right' : 'Left')+'</span></div>';
            html += '<div class="profile-row"><span>Role</span><span class="pval">'+role+'</span></div>';
            html += '<div class="profile-row"><span>H-Break</span><span class="pval">'+((ps.pfx_x_avg||0)*12).toFixed(1)+'"</span></div>';
            html += '<div class="profile-row"><span>V-Break</span><span class="pval">'+((ps.pfx_z_avg||0)*12).toFixed(1)+'"</span></div>';

            // Head-to-head matchup if batter is active
            if (batterObj) {
                const hvpData = (DATA._hvpIndex[batterObj.batter] || {})[ps.cluster] || [];
                const matchup = hvpData.find(m => m.p === ps.pitcher);

                if (matchup) {
                    html += '<div class="section-hdr">vs '+fmtName(batterObj.batter_name)+'</div>';
                    html += '<div class="stat-grid">';
                    html += statCell('PA', matchup.pa||0);
                    html += statCell('BA', matchup.ba != null ? matchup.ba.toFixed(3) : '\u2014');
                    html += statCell('wOBA', matchup.w != null ? matchup.w.toFixed(3) : '\u2014');
                    html += statCell('HR', matchup.hr||0);
                    html += statCell('K', matchup.k||0);
                    html += statCell('BB', matchup.bb||0);
                    html += '</div>';
                } else {
                    html += '<div class="section-hdr">vs '+fmtName(batterObj.batter_name)+'</div>';
                    html += '<div style="font-size:11px;color:#666;font-family:var(--font-tech);padding:4px 0;">No direct matchup data</div>';
                }
            }

            // Link to full archetype
            html += '<div class="section-hdr">Archetype</div>';
            html += '<div class="arch-link" data-cluster="'+ps.cluster+'" style="cursor:pointer;padding:6px 8px;background:#1a1a1a;border:1px solid #2a2a2a;border-radius:3px;display:flex;align-items:center;gap:6px;transition:border-color 0.15s;">';
            html += '<span style="width:8px;height:8px;border-radius:50%;background:'+cluster.color+';flex-shrink:0;"></span>';
            html += '<span style="font-size:11px;font-weight:700;color:#eee;font-family:var(--font-tech);">'+cluster.short_name+'</span>';
            html += '<span style="font-size:9px;color:#888;margin-left:auto;">'+cluster.hand+' '+role+' \u2022 '+cluster.pitcher_count+' pitchers \u2192</span>';
            html += '</div>';

            content.innerHTML = html;
            panel.classList.add('visible');
            STATE.highlightedCluster = ps.cluster;

            // Click handler for archetype link
            const archLink = content.querySelector('.arch-link');
            if (archLink) {
                archLink.addEventListener('click', () => {
                    showStatPanel(batterObj, ps.cluster);
                });
                archLink.addEventListener('mouseenter', () => { archLink.style.borderColor = cluster.color; });
                archLink.addEventListener('mouseleave', () => { archLink.style.borderColor = '#2a2a2a'; });
            }

            render();
            buildArchetypeList();
            // Update dock kings
            if (STATE.activeBatters.length > 0) {
                updateDock(batterObj || STATE.activeBatters[STATE.activeBatters.length-1], getMatchupData(batterObj || STATE.activeBatters[STATE.activeBatters.length-1]));
            }
        }

        // ═══════════════════════════════════════
        // ARCHETYPE LIST (sidebar)
        // ═══════════════════════════════════════
        function perfClass(stat, val) {
            if (stat === 'K_pct') return val < 0.15 ? 'perf-great' : val < 0.20 ? 'perf-good' : val > 0.30 ? 'perf-bad' : val > 0.25 ? 'perf-poor' : 'perf-avg';
            if (stat === 'BB_pct') return val > 0.12 ? 'perf-great' : val > 0.10 ? 'perf-good' : val < 0.05 ? 'perf-bad' : val < 0.07 ? 'perf-poor' : 'perf-avg';
            // wOBA, BA, SLG, OBP
            return val >= 0.370 ? 'perf-great' : val >= 0.330 ? 'perf-good' : val >= 0.290 ? 'perf-avg' : val >= 0.250 ? 'perf-poor' : 'perf-bad';
        }

        // Returns a hex color for the archetype row based on batter performance
        function perfHex(stat, val) {
            if (stat === 'K_pct') {
                // Lower K% = better for batter
                return val < 0.15 ? '#2a9d8f' : val < 0.20 ? '#6bbe8a' : val > 0.30 ? '#e63946' : val > 0.25 ? '#e76f51' : '#f4a261';
            }
            if (stat === 'BB_pct') {
                // Higher BB% = better for batter
                return val > 0.12 ? '#2a9d8f' : val > 0.10 ? '#6bbe8a' : val < 0.05 ? '#e63946' : val < 0.07 ? '#e76f51' : '#f4a261';
            }
            // wOBA, BA, SLG — higher = better
            return val >= 0.370 ? '#2a9d8f' : val >= 0.330 ? '#6bbe8a' : val >= 0.290 ? '#f4a261' : val >= 0.250 ? '#e76f51' : '#e63946';
        }

        function buildArchetypeList() {
            const dir = document.getElementById('archetype-list');
            const ids = Object.keys(DATA.clusters);
            const rhp = ids.filter(id => DATA.clusters[id].hand === 'RHP').sort();
            const lhp = ids.filter(id => DATA.clusters[id].hand === 'LHP').sort();
            const batters = STATE.activeBatters;
            const hasBatters = batters.length > 0;

            // Pre-compute matchup data for all active batters
            const allMatchups = batters.map(b => getMatchupData(b));

            let html = '';

            // Column headers when batters are active
            if (hasBatters) {
                html += '<div class="arch-batter-cols">';
                html += '<span class="col-label col-archetype">ARCHETYPE</span>';
                batters.forEach(b => {
                    const lastName = fmtName(b.batter_name).split(' ').pop();
                    html += '<span class="col-label" style="width:44px;">'+lastName+'</span>';
                });
                html += '</div>';
            }

            const renderGroup = (group, label) => {
                html += '<div class="arch-group-header">'+label+' ('+group.length+')</div>';
                group.forEach(id => {
                    const c = DATA.clusters[id];
                    const cent = c.centroid || {};
                    const role = cent.is_sp > 0.5 ? 'SP' : 'RP';
                    const vis = STATE.visibleClusters.has(id);
                    const sel = STATE.highlightedCluster === id;
                    const cls = 'arch-item' + (sel ? ' selected' : '') + (!vis ? ' dimmed' : '');

                    // Determine row color from most recent batter's matchup
                    let rowColor = c.color;
                    let dotColor = c.color;
                    if (hasBatters) {
                        const lastMatchups = allMatchups[allMatchups.length - 1];
                        const lm = lastMatchups.find(x => String(x.cluster) === id);
                        if (lm && lm.PA >= STATE.minPA) {
                            const lv = lm[STATE.selectedStat] || 0;
                            rowColor = perfHex(STATE.selectedStat, lv);
                            dotColor = rowColor;
                        } else {
                            rowColor = '#666';
                            dotColor = '#666';
                        }
                    }

                    html += '<div class="'+cls+'" data-cluster="'+id+'">';
                    html += '<div class="arch-dot" style="background:'+dotColor+';"></div>';
                    html += '<span class="arch-name" style="color:'+(vis ? rowColor : '#aaa')+';">'+c.short_name+'</span>';
                    html += '<span class="arch-role" style="color:'+rowColor+';border-color:'+rowColor+';">'+role+'</span>';

                    if (hasBatters) {
                        batters.forEach((b, bi) => {
                            const matchups = allMatchups[bi];
                            const m = matchups.find(x => String(x.cluster) === id);
                            if (m && m.PA >= STATE.minPA) {
                                const val = m[STATE.selectedStat] || 0;
                                const display = (STATE.selectedStat === 'K_pct' || STATE.selectedStat === 'BB_pct')
                                    ? (val*100).toFixed(0)+'%' : val.toFixed(3);
                                const pClass = perfClass(STATE.selectedStat, val);
                                html += '<span class="arch-stat '+pClass+'">'+display+'</span>';
                            } else {
                                html += '<span class="arch-stat empty">\u2014</span>';
                            }
                        });
                    } else {
                        html += '<span class="arch-count">'+c.pitcher_count+'</span>';
                    }

                    html += '</div>';
                });
            };
            renderGroup(rhp, 'Right-Handed');
            renderGroup(lhp, 'Left-Handed');
            dir.innerHTML = html;

            dir.querySelectorAll('.arch-item').forEach(el => {
                el.addEventListener('click', () => {
                    const id = el.dataset.cluster;
                    if (STATE.highlightedCluster === id) {
                        STATE.highlightedCluster = null;
                        document.getElementById('stat-panel').classList.remove('visible');
                    } else {
                        STATE.highlightedCluster = id;
                        const ab = STATE.activeBatters.length > 0 ? STATE.activeBatters[STATE.activeBatters.length-1] : null;
                        showStatPanel(ab, id);
                    }
                    // Update dock kings to reflect selected archetype
                    if (STATE.activeBatters.length > 0) {
                        const ab = STATE.activeBatters[STATE.activeBatters.length-1];
                        updateDock(ab, getMatchupData(ab));
                    }
                    render();
                    buildArchetypeList();
                });
            });
        }

        // ═══════════════════════════════════════
        // DOCK
        // ═══════════════════════════════════════
        function updateDock(batter, matchups) {
            const valid = matchups.filter(m => (m.PA||0) >= STATE.minPA);
            const sorted = [...valid].sort((a,b) => (b.wOBA||0) - (a.wOBA||0));

            const bestEl = document.getElementById('dock-best-content');
            const worstEl = document.getElementById('dock-worst-content');
            const kingsEl = document.getElementById('dock-kings-content');

            if (sorted.length > 0) {
                bestEl.innerHTML = sorted.slice(0,3).map(m => {
                    const cl = DATA.clusters[m.cluster];
                    return '<div class="dock-row"><span class="d-name" style="color:'+(cl?.color||'#333')+'">'+( cl?.short_name||m.cluster)+'</span><span class="d-stat">'+m.PA+'PA</span><span class="d-stat good">'+(m.wOBA||0).toFixed(3)+'</span></div>';
                }).join('');
                worstEl.innerHTML = sorted.slice(-3).reverse().map(m => {
                    const cl = DATA.clusters[m.cluster];
                    return '<div class="dock-row"><span class="d-name" style="color:'+(cl?.color||'#333')+'">'+( cl?.short_name||m.cluster)+'</span><span class="d-stat">'+m.PA+'PA</span><span class="d-stat bad">'+(m.wOBA||0).toFixed(3)+'</span></div>';
                }).join('');
            } else {
                bestEl.innerHTML = '<span style="color:var(--text-label)">Not enough PA</span>';
                worstEl.innerHTML = '<span style="color:var(--text-label)">Not enough PA</span>';
            }

            // Kings — prioritize highlighted cluster from sidebar, fall back to top performer
            let kingsClusterId = null;
            if (STATE.highlightedCluster && DATA.clusters[STATE.highlightedCluster]) {
                kingsClusterId = STATE.highlightedCluster;
            } else if (sorted.length > 0) {
                kingsClusterId = sorted[0].cluster;
            }
            if (kingsClusterId) {
                const kings = DATA.archetypeKings[kingsClusterId] || [];
                const cl = DATA.clusters[kingsClusterId];
                kingsEl.innerHTML = kings.length > 0
                    ? '<div style="font-size:8px;color:'+(cl?.color)+';font-weight:700;margin-bottom:2px;">'+(cl?.short_name)+' KINGS</div>' + kings.slice(0,5).map(k => '<div class="dock-row"><span class="d-name">'+k.name+'</span><span class="d-stat" style="width:20px;">'+k.seasons+'yr</span></div>').join('')
                    : '<span style="color:var(--text-label)">\u2014</span>';
            }
        }

        // ═══════════════════════════════════════
        // SAVED SEARCHES
        // ═══════════════════════════════════════
        function saveSearch(batter) {
            const idx = STATE.savedSearches.findIndex(s => s.batter === batter.batter);
            if (idx >= 0) STATE.savedSearches.splice(idx, 1);
            STATE.savedSearches.unshift({ batter: batter.batter, batter_name: batter.batter_name, total_PA: batter.total_PA });
            if (STATE.savedSearches.length > 10) STATE.savedSearches = STATE.savedSearches.slice(0, 10);
            localStorage.setItem('pfx_saved', JSON.stringify(STATE.savedSearches));
            renderSaved();
        }

        function renderSaved() {
            const div = document.getElementById('dock-saved-content');
            if (STATE.savedSearches.length === 0) { div.innerHTML = '<span style="color:var(--text-label)">No saved searches</span>'; return; }
            div.innerHTML = STATE.savedSearches.map(s => '<div class="saved-item" data-bid="'+s.batter+'"><span>'+fmtName(s.batter_name)+'</span><span class="s-pa">'+(s.total_PA||0).toLocaleString()+' PA</span></div>').join('');
            div.querySelectorAll('.saved-item').forEach(el => {
                el.addEventListener('click', () => {
                    const b = DATA.batters.find(x => x.batter === parseInt(el.dataset.bid));
                    if (b) addBatter(b);
                });
            });
        }

        // ═══════════════════════════════════════
        // SEARCH
        // ═══════════════════════════════════════
        let fuse = null;
        function initSearch() { fuse = new Fuse(DATA.batters, { keys: ['batter_name'], threshold: 0.3, distance: 100 }); }

        const searchInput = document.getElementById('batter-search');
        const searchDrop = document.getElementById('search-dropdown');
        let sHighlight = 0, sResults = [];

        searchInput.addEventListener('input', () => {
            const q = searchInput.value;
            if (q.length < 2) { searchDrop.classList.remove('visible'); return; }
            sResults = fuse.search(q).slice(0,8).map(r => r.item);
            sHighlight = 0;
            renderSearchResults();
        });
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown') { e.preventDefault(); sHighlight = Math.min(sHighlight+1, sResults.length-1); renderSearchResults(); }
            else if (e.key === 'ArrowUp') { e.preventDefault(); sHighlight = Math.max(sHighlight-1, 0); renderSearchResults(); }
            else if (e.key === 'Enter') { e.preventDefault(); if (sResults[sHighlight]) selectResult(sResults[sHighlight]); }
            else if (e.key === 'Escape') searchDrop.classList.remove('visible');
        });

        function renderSearchResults() {
            if (sResults.length === 0) { searchDrop.classList.remove('visible'); return; }
            searchDrop.innerHTML = sResults.map((b,i) =>
                '<div class="search-result '+(i===sHighlight?'highlighted':'')+'" data-idx="'+i+'"><span>'+fmtName(b.batter_name)+'</span><span class="pa-label">'+(b.total_PA||0).toLocaleString()+' PA</span></div>'
            ).join('');
            searchDrop.classList.add('visible');
        }

        // Delegated handlers on the dropdown container — survive innerHTML rebuilds
        searchDrop.addEventListener('mousedown', (e) => {
            const el = e.target.closest('.search-result');
            if (!el) return;
            e.preventDefault();
            e.stopPropagation();
            selectResult(sResults[parseInt(el.dataset.idx)]);
        });
        searchDrop.addEventListener('mouseover', (e) => {
            const el = e.target.closest('.search-result');
            if (!el) return;
            const idx = parseInt(el.dataset.idx);
            if (idx !== sHighlight) {
                sHighlight = idx;
                searchDrop.querySelectorAll('.search-result').forEach((r, i) => {
                    r.classList.toggle('highlighted', i === sHighlight);
                });
            }
        });

        function selectResult(batter) { addBatter(batter); searchInput.value = ''; searchDrop.classList.remove('visible'); searchInput.focus(); }

        function addBatter(batter) {
            STATE.activeBatters = STATE.activeBatters.filter(b => b.batter !== batter.batter);
            if (STATE.activeBatters.length >= 5) STATE.activeBatters.shift();
            STATE.activeBatters.push(batter);
            renderBatterStack();
            playScan(batter.batter_name);
            setTimeout(() => spawnBatter(batter), 300);
        }

        function removeBatter(id) {
            STATE.activeBatters = STATE.activeBatters.filter(b => b.batter !== id);
            renderBatterStack();
            if (STATE.activeBatters.length > 0) spawnBatter(STATE.activeBatters[STATE.activeBatters.length-1]);
            else { clearBatter(); buildArchetypeList(); }
        }

        function renderBatterStack() {
            const el = document.getElementById('batter-stack');
            el.innerHTML = STATE.activeBatters.map(b =>
                '<div class="batter-chip" data-id="'+b.batter+'">'+fmtName(b.batter_name)+'<span class="remove" data-id="'+b.batter+'">\u2715</span></div>'
            ).join('');
            el.querySelectorAll('.remove').forEach(r => {
                r.addEventListener('click', (e) => { e.stopPropagation(); removeBatter(parseInt(r.dataset.id)); });
            });
        }

        function playScan(name) {
            const o = document.getElementById('scan-overlay');
            o.innerHTML = '<div class="scan-line"></div><div class="scan-text">SCANNING: '+name.toUpperCase()+'</div>';
            o.classList.add('active');
            document.getElementById('led-scan').classList.add('active');
            setTimeout(() => { o.classList.remove('active'); o.innerHTML = ''; document.getElementById('led-scan').classList.remove('active'); }, 900);
        }

        // ═══════════════════════════════════════
        // UI CONTROLS
        // ═══════════════════════════════════════
        document.getElementById('metric-keys').addEventListener('click', (e) => {
            const key = e.target.closest('.key');
            if (!key || !key.dataset.stat) return;
            document.querySelectorAll('#metric-keys .key').forEach(k => { k.className = 'key key-dark'; });
            key.className = 'key key-orange';
            STATE.selectedStat = key.dataset.stat;
            refreshData(); buildArchetypeList();
        });

        document.getElementById('filter-keys').addEventListener('click', (e) => {
            const key = e.target.closest('.key');
            if (!key || !key.dataset.filter) return;
            document.querySelectorAll('#filter-keys .key').forEach(k => { k.className = 'key key-dark'; });
            key.className = 'key key-orange';
            const filter = key.dataset.filter;
            Object.keys(DATA.clusters).forEach(id => {
                const c = DATA.clusters[id];
                const show = filter === 'all' || c.hand === filter;
                if (show) STATE.visibleClusters.add(id); else STATE.visibleClusters.delete(id);
            });
            render(); refreshData(); buildArchetypeList();
        });

        document.getElementById('year-select').addEventListener('change', (e) => {
            STATE.selectedYear = e.target.value; refreshData(); buildArchetypeList(); render();
        });

        const paSlider = document.getElementById('pa-slider'), paVal = document.getElementById('pa-val');
        paSlider.addEventListener('input', () => {
            STATE.minPA = parseInt(paSlider.value); paVal.textContent = STATE.minPA;
            refreshData(); buildArchetypeList(); render();
        });

        document.getElementById('stat-close').addEventListener('click', () => {
            document.getElementById('stat-panel').classList.remove('visible');
            STATE.highlightedCluster = null;
            // Revert dock kings to top performer
            if (STATE.activeBatters.length > 0) {
                const ab = STATE.activeBatters[STATE.activeBatters.length-1];
                updateDock(ab, getMatchupData(ab));
            }
            render(); buildArchetypeList();
        });

        // Roster sort handler (delegated)
        document.getElementById('panel-content').addEventListener('click', (e) => {
            const sortBtn = e.target.closest('.sort-btn');
            if (!sortBtn) return;
            const rosterList = document.getElementById('roster-list');
            if (!rosterList) return;
            const clusterId = rosterList.dataset.cluster;
            const batterId = parseInt(rosterList.dataset.batter);
            const sortKey = sortBtn.dataset.sort;

            // Update active button
            sortBtn.parentElement.querySelectorAll('.sort-btn').forEach(b => b.classList.remove('active'));
            sortBtn.classList.add('active');

            const pitcherMatchups = (DATA._hvpIndex[batterId] || {})[clusterId] || [];
            let sorted;
            if (sortKey === 'pa') sorted = [...pitcherMatchups].sort((a,b) => (b.pa||0) - (a.pa||0));
            else if (sortKey === 'ba') sorted = [...pitcherMatchups].sort((a,b) => (b.ba||0) - (a.ba||0));
            else if (sortKey === 'hr') sorted = [...pitcherMatchups].sort((a,b) => (b.hr||0) - (a.hr||0));
            else if (sortKey === 'k') sorted = [...pitcherMatchups].sort((a,b) => (b.k||0) - (a.k||0));
            else sorted = pitcherMatchups;

            rosterList.innerHTML = sorted.map(m => {
                const baVal = m.ba != null ? m.ba.toFixed(3) : '\u2014';
                const whiff = m.w != null ? (m.w*100).toFixed(0)+'%' : '\u2014';
                const baColor = m.ba != null ? (m.ba >= 0.300 ? 'color:var(--perf-green)' : m.ba <= 0.180 ? 'color:var(--perf-red)' : '') : '';
                return '<div class="roster-row"><span class="r-name">'+fmtName(m.pn)+'</span><span class="r-val">'+(m.pa||0)+'</span><span class="r-val highlight" style="'+baColor+'">'+baVal+'</span><span class="r-val">'+(m.hr||0)+'</span><span class="r-val">'+(m.k||0)+'</span><span class="r-val">'+whiff+'</span></div>';
            }).join('');
        });

        // ═══════════════════════════════════════
        // HISTORY PANEL
        // ═══════════════════════════════════════
        const historyPanel = document.getElementById('history-panel');
        const historyContent = document.getElementById('history-content');

        document.getElementById('history-toggle').addEventListener('click', () => {
            historyPanel.classList.toggle('visible');
            if (historyPanel.classList.contains('visible')) renderHistory();
        });

        document.getElementById('history-clear').addEventListener('click', () => {
            STATE.savedSearches = [];
            localStorage.setItem('pfx_saved', JSON.stringify(STATE.savedSearches));
            renderHistory();
            renderSaved();
        });

        function renderHistory() {
            if (STATE.savedSearches.length === 0) {
                historyContent.innerHTML = '<div class="history-empty">No search history yet.<br>Search for a batter to begin.</div>';
                return;
            }
            const activeId = STATE.activeBatters.length > 0 ? STATE.activeBatters[STATE.activeBatters.length-1].batter : null;
            historyContent.innerHTML = STATE.savedSearches.map(s => {
                const isActive = s.batter === activeId;
                return '<div class="history-item'+(isActive ? ' active' : '')+'" data-bid="'+s.batter+'">'
                    +'<span class="h-name">'+fmtName(s.batter_name)+'</span>'
                    +'<span class="h-pa">'+(s.total_PA||0).toLocaleString()+' PA</span>'
                    +'<span class="h-remove" data-bid="'+s.batter+'">\u2715</span>'
                    +'</div>';
            }).join('');

            historyContent.querySelectorAll('.history-item').forEach(el => {
                el.addEventListener('click', (e) => {
                    if (e.target.classList.contains('h-remove')) return;
                    const b = DATA.batters.find(x => x.batter === parseInt(el.dataset.bid));
                    if (b) { addBatter(b); renderHistory(); }
                });
            });
            historyContent.querySelectorAll('.h-remove').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const bid = parseInt(el.dataset.bid);
                    STATE.savedSearches = STATE.savedSearches.filter(s => s.batter !== bid);
                    localStorage.setItem('pfx_saved', JSON.stringify(STATE.savedSearches));
                    renderHistory();
                    renderSaved();
                });
            });
        }

        // Close history panel when clicking elsewhere
        document.addEventListener('mousedown', (e) => {
            if (!e.target.closest('.search-box') && !e.target.closest('.search-dropdown')) searchDrop.classList.remove('visible');
            if (!e.target.closest('.history-panel') && !e.target.closest('#history-toggle')) historyPanel.classList.remove('visible');
        });

        function fmtName(name) {
            if (!name) return 'Unknown';
            return name.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        }

        // ═══════════════════════════════════════
        // RESIZE
        // ═══════════════════════════════════════
        window.addEventListener('resize', resizeCanvas);

        // ═══════════════════════════════════════
        // BOOT
        // ═══════════════════════════════════════
        async function boot() {
            try {
                await loadAllData();
                resizeCanvas();
                buildArchetypeList();
                initSearch();
                renderSaved();
                const total = DATA.pitcherSeasons.length;
                document.getElementById('sidebar-status').textContent =
                    Object.keys(DATA.clusters).length + ' ARCHETYPES \u00b7 ' + total.toLocaleString() + ' SEASONS \u00b7 ' + DATA.batters.length.toLocaleString() + ' BATTERS';
                document.getElementById('led-data').classList.add('green');
                setTimeout(() => {
                    const loader = document.getElementById('loader');
                    loader.style.opacity = '0';
                    setTimeout(() => loader.remove(), 800);
                }, 500);
            } catch (err) {
                console.error('Boot failed:', err);
                document.getElementById('loader-status').textContent = 'ERROR: ' + err.message;
            }
        }
        boot();
    })();
    </script>
</body>
</html>
